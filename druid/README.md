
Druid介绍
==========================================

## Druid的概念   

Druid本来是一个开源的数据存储,为[OLAP](http://en.wikipedia.org/wiki/Online_analytical_processing)的事件查询而设计，
有兴趣的朋友可以关注下广东数果对于druid的[翻译](http://druidio.cn)。
我们目前基于lucene，剔除lucene的词向量、行正向等非必要的信息，并做了多处优化，重新设计了一套Druid的索引，在保证其原有的查询功能的前提下，主要改动涉及以下方面：  

* 重新设计了索引层，基于原始数据查询，可随时定制查询指标，不再需要提前指定指标
* 增强了维度支持，目前测试可支持上万维度
* 支持了多种数据类型（int/long/String/date/float/text等，后续会支持地理位置信息）
* 实现了按需加载，用户可以配置LRU按需加载策略，解决了原有的Druid在行数达到一定的情况下加载慢，甚至不可查等问题
* 支持了更多的查询，例如留存查询、漏斗查询及用户分群等
* 支持了更多查询相关的功能，如数字分组、日期分组查询
* 优化了查询聚合，避免虚函数的性能损耗
* 支持分词

## 为什么选择Druid框架  

我们一直希望做一款针对万亿、上千维度的数据，做到能够实时查询，满足自由定义查询指标的产品。预研了Hbase类似的KV的存储结构、基于Dremal的列式存储方案，
甚至MPP的并行计算的方案，都无法满足我们。   

14-15年期间，针对大数据的各种预聚合计算的方案进入开源的白热化阶段，我们发现Druid针对数十维度的场景下使用非常完美。
经过对其源码的详细深入和社区的交流，我们发现其框架扩展性、查询引擎设计的非常好，很多性能细节都考虑在内。例如：  

 * 堆外内存的复用，避免GC问题；  
 * 根据查询数据的粒度，以Sequence的方式构建小批量的数据，内存利用率更高；  
 * 查询有bySegment级别的缓存，可以做到大范围固定模式的查询；  
 * 多种query，最大化提升查询性能，例如topN、timeSeries等查询等等。  

另外框架可灵活的扩展，也是我们考虑的一个很重要的元素，在我们重写了索引后，Druid社区针对高基数维度的查询上线了groupByV2，我们很快就完成了groupByV2也可见其框架非常灵活。  

在我们看来，Druid的查询引擎很强大，但是索引层还是针对OLAP查询的场景，这就是我们选择Druid框架进行索引扩展的根本原因。
另外其充分考虑分布式的稳定性，HA策略，针对不同的机器设备情况和应用场景，灵活的配置最大化利用硬件性能来满足场景需要也是我们所看重的。

## Druid服务的结构

虽然我们对Druid索引的重构，但是Druid的框架灵活性使得我们的改造并未影响其接口和服务层。所以，最终的产品形态和Druid的框架结构一致。
Druid的服务节点由五种类型组成：  
 
 * Overlord：用于管理实时任务的调度，新版本有支持Supervisor，可以监听实时任务的状态，挂掉的task可以自动拉起，需要zookeeper选举leader；  
 * Coordinator：协调数据段的管理，所有的数据段管理都由其统一调配，，需要zookeeper选举leader；  
 * MiddleManager：负责实时task任务的调起；  
 * Broker：分发查询任务及合并查询结果；
 * History：查询每一个具体的历史数据段。  
 
Druid的服务介绍不在此多介绍了，有兴趣可以了解下广东数果对于Druid设计的[翻译](http://druidio.cn/docs/0.9.0/design/design.html)。  

